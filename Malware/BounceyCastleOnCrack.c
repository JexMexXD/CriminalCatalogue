#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <math.h>
#include <mmsystem.h>

#pragma comment(lib, "winmm.lib")

#define FLASH_DELAY 30 // seconds before overlay
#define CYCLE_TIME 60  // seconds before repeat

HWND hOverlay = NULL;
int screenWidth, screenHeight;
volatile int startFlashing = 0;

// Overlay window procedure for **super intense** colorful lights with many shapes
LRESULT CALLBACK OverlayProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    static int frame = 0;
    switch (msg) {
    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        // SUPER INTENSE: Dense, fast, and varied shapes/colors!
        for (int y = 0; y < screenHeight; y += 8) {
            for (int x = 0; x < screenWidth; x += 8) {
                // Wild color patterns
                int r = (int)(128 + 127 * sin((x * 0.25 + frame * 8) * 0.25 + y * 0.05));
                int g = (int)(128 + 127 * cos((y * 0.35 + frame * 12) * 0.35 + x * 0.07));
                int b = (int)(128 + 127 * sin((x * 0.2 + y * 0.2 + frame * 16) * 0.4));
                HBRUSH brush = CreateSolidBrush(RGB(r, g, b));
                RECT rect = { x, y, x + 8, y + 8 };
                FillRect(hdc, &rect, brush);

                // Ellipse
                SelectObject(hdc, GetStockObject(NULL_BRUSH));
                Ellipse(hdc, x + (frame % 8), y + (frame % 8), x + 7 + (frame % 4), y + 7 + (frame % 4));

                // Rectangle with XOR pen
                HPEN pen = CreatePen(PS_DOT, 1, RGB(255 - r, 255 - g, 255 - b));
                HGDIOBJ oldPen = SelectObject(hdc, pen);
                Rectangle(hdc, x + 1, y + 1, x + 7, y + 7);
                SelectObject(hdc, oldPen);
                DeleteObject(pen);

                // Triangle (polygon)
                POINT pts[3] = {
                    { x + 4, y + 1 + (frame % 3) },
                    { x + 1 + (frame % 2), y + 7 },
                    { x + 7 - (frame % 2), y + 7 }
                };
                HPEN triPen = CreatePen(PS_SOLID, 1, RGB(r, 255 - g, b));
                HGDIOBJ oldTriPen = SelectObject(hdc, triPen);
                Polygon(hdc, pts, 3);
                SelectObject(hdc, oldTriPen);
                DeleteObject(triPen);

                // Star (drawn as two crossing lines)
                HPEN starPen = CreatePen(PS_SOLID, 1, RGB(255, r, g));
                HGDIOBJ oldStarPen = SelectObject(hdc, starPen);
                MoveToEx(hdc, x + 2, y + 2, NULL);
                LineTo(hdc, x + 6, y + 6);
                MoveToEx(hdc, x + 6, y + 2, NULL);
                LineTo(hdc, x + 2, y + 6);
                SelectObject(hdc, oldStarPen);
                DeleteObject(starPen);

                DeleteObject(brush);
            }
        }
        EndPaint(hwnd, &ps);
        return 0;
    }
    case WM_TIMER:
        frame++;
        InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
}

// Thread to create and run the overlay window
DWORD WINAPI FlashThread(LPVOID lpParam) {
    HINSTANCE hInstance = GetModuleHandle(NULL);
    WNDCLASS wc = { 0 };
    wc.lpfnWndProc = OverlayProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = "FunkyOverlay";
    wc.hbrBackground = NULL;
    RegisterClass(&wc);

    screenWidth = GetSystemMetrics(SM_CXSCREEN);
    screenHeight = GetSystemMetrics(SM_CYSCREEN);

    hOverlay = CreateWindowEx(
        WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TRANSPARENT,
        "FunkyOverlay", "",
        WS_POPUP,
        0, 0, screenWidth, screenHeight,
        NULL, NULL, hInstance, NULL);

    SetLayeredWindowAttributes(hOverlay, 0, 128, LWA_ALPHA);

    ShowWindow(hOverlay, SW_SHOW);
    SetTimer(hOverlay, 1, 50, NULL); // 20 FPS

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return 0;
}

// Move all windows randomly
BOOL CALLBACK MoveWindowProc(HWND hwnd, LPARAM lParam) {
    RECT rect;
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);

    if (!IsWindowVisible(hwnd) || IsIconic(hwnd)) return TRUE;

    char className[256];
    GetClassNameA(hwnd, className, sizeof(className));
    if (strcmp(className, "Shell_TrayWnd") == 0) return TRUE;
    if (hwnd == hOverlay) return TRUE;

    if (GetWindowRect(hwnd, &rect)) {
        int winWidth = rect.right - rect.left;
        int winHeight = rect.bottom - rect.top;
        if (winWidth < screenWidth && winHeight < screenHeight) {
            int x = rand() % (screenWidth - winWidth);
            int y = rand() % (screenHeight - winHeight);
            MoveWindow(hwnd, x, y, winWidth, winHeight, TRUE);
        }
    }
    return TRUE;
}

void PlayAudio(const char* path) {
    char command[512];
    mciSendStringA("close myAudio", NULL, 0, NULL); // Ensure previous is closed
    snprintf(command, sizeof(command), "open \"%s\" type waveaudio alias myAudio", path);
    mciSendStringA(command, NULL, 0, NULL);
    mciSendStringA("play myAudio", NULL, 0, NULL);
}

void CloseOverlay() {
    if (hOverlay) {
        DestroyWindow(hOverlay);
        hOverlay = NULL;
    }
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmd, int nShow) {
    srand((unsigned)time(NULL));

    while (1) {
        DWORD startTime = GetTickCount();
        HANDLE hThread = NULL;
        startFlashing = 0;

        // Play audio at start (change path to your .wav file if needed)
        PlayAudio("C:\\Users\\User\\Downloads\\FirstAudioBass.wav.wav");

        // 1st phase: move windows for FLASH_DELAY seconds
        while ((GetTickCount() - startTime) < FLASH_DELAY * 1000) {
            EnumWindows(MoveWindowProc, 0);
            Sleep(50);
        }

        // 2nd phase: move windows + overlay for (CYCLE_TIME-FLASH_DELAY) seconds
        startFlashing = 1;
        hThread = CreateThread(NULL, 0, FlashThread, NULL, 0, NULL);

        DWORD overlayStart = GetTickCount();
        while ((GetTickCount() - overlayStart) < (CYCLE_TIME - FLASH_DELAY) * 1000) {
            EnumWindows(MoveWindowProc, 0);
            Sleep(50);
        }

        // Clean up overlay for next cycle
        CloseOverlay();
        mciSendStringA("close myAudio", NULL, 0, NULL); // Stop audio if still playing
    }
    return 0;
}